commit f7a0baab8e5073cfb5893106352da2a8f12a4c58
Author: Christophe Staïesse <chastai@skynet.be>
Date:   Sat Jul 13 11:31:58 2013 +0200

    Rename .p file extensions to .pas

commit 49259726c5f6d452c8fdc1cd29b77cb82b2b5a56
Author: Christophe Staïesse <chastai@skynet.be>
Date:   Sat Jul 13 11:36:37 2013 +0200

    TAB expansion

commit a860a0fb68a93875253a034c7d0824ec0a0a31c5
Author: Christophe Staïesse <chastai@skynet.be>
Date:   Sat Jul 13 11:41:44 2013 +0200

    Rename identifiers which are kw in FPC or Delphi
    
    operator to operatr
    string to strng

diff --git a/pcom.pas b/pcom.pas
index 472b1ea..660458b 100644
--- a/pcom.pas
+++ b/pcom.pas
@@ -84,7 +84,7 @@ type                                                    (*describing:*)
                beginsy,ifsy,casesy,repeatsy,whilesy,forsy,withsy,
                gotosy,endsy,elsesy,untilsy,ofsy,dosy,tosy,downtosy,
                thensy,othersy);
-     operator = (mul,rdiv,andop,idiv,imod,plus,minus,orop,ltop,leop,geop,gtop,
+     operatr = (mul,rdiv,andop,idiv,imod,plus,minus,orop,ltop,leop,geop,gtop,
                  neop,eqop,inop,noop);
      setofsys = set of symbol;
      chtp = (letter,number,special,illegal,
@@ -197,7 +197,7 @@ var
                                      **********)
 
     sy: symbol;              (*last symbol*)
-    op: operator;                  (*classification of last symbol*)
+    op: operatr;                  (*classification of last symbol*)
     val: valu;                (*value of last constant*)
     lgth: integer;                (*length of last string constant*)
     id: alpha;                (*last identifier (possibly truncated)*)
@@ -286,8 +286,8 @@ var
     frw: array [1..9] of 1..36(*nr. of res. words + 1*);
     rsy: array [1..35(*nr. of res. words*)] of symbol;
     ssy: array [char] of symbol;
-    rop: array [1..35(*nr. of res. words*)] of operator;
-    sop: array [char] of operator;
+    rop: array [1..35(*nr. of res. words*)] of operatr;
+    sop: array [char] of operatr;
     na:  array [1..35] of alpha;
     mn:  array [0..60] of packed array [1..4] of char;
     sna: array [1..23] of packed array [1..4] of char;
@@ -352,7 +352,7 @@ var
     label 1,2,3;
     var i,k: integer;
         digit: packed array [1..strglgth] of char;
-        string: packed array [1..strglgth] of char;
+        strng: packed array [1..strglgth] of char;
         lvp: csp; test: boolean;
 
     procedure nextch;
@@ -482,20 +482,20 @@ var
         begin lgth := 0; sy := stringconst;  op := noop;
           repeat
             repeat nextch; lgth := lgth + 1;
-                   if lgth <= strglgth then string[lgth] := ch
+                   if lgth <= strglgth then strng[lgth] := ch
             until (eol) or (ch = '''');
             if eol then error(202) else nextch
           until ch <> '''';
-          lgth := lgth - 1;   (*now lgth = nr of chars in string*)
+          lgth := lgth - 1;   (*now lgth = nr of chars in strng*)
           if lgth = 0 then error(205) else
-          if lgth = 1 then val.ival := ord(string[1])
+          if lgth = 1 then val.ival := ord(strng[1])
           else
             begin new(lvp,strg); lvp^.cclass:=strg;
               if lgth > strglgth then
                 begin error(399); lgth := strglgth end;
               with lvp^ do
                 begin slgth := lgth;
-                  for i := 1 to lgth do sval[i] := string[i]
+                  for i := 1 to lgth do sval[i] := strng[i]
                 end;
               val.valp := lvp
             end
@@ -1015,12 +1015,12 @@ var
         else comptypes := true
     end (*comptypes*) ;
 
-    function string(fsp: stp) : boolean;
-    begin string := false;
+    function strng(fsp: stp) : boolean;
+    begin strng := false;
       if fsp <> nil then
         if fsp^.form = arrays then
-          if comptypes(fsp^.aeltype,charptr) then string := true
-    end (*string*) ;
+          if comptypes(fsp^.aeltype,charptr) then strng := true
+    end (*strng*) ;
 
     procedure typ(fsys: setofsys; var fsp: stp; var fsize: addrrange);
       var lsp,lsp1,lsp2: stp; oldtop: disprange; lcp: ctp;
@@ -1070,7 +1070,7 @@ var
                       begin new(lsp,subrange);
                         with lsp^, lcp^ do
                           begin rangetype := idtype; form := subrange;
-                            if string(rangetype) then
+                            if strng(rangetype) then
                               begin error(148); rangetype := nil end;
                             min := values; size := intsize
                           end;
@@ -1087,7 +1087,7 @@ var
                 else
                   begin new(lsp,subrange); lsp^.form := subrange;
                     constant(fsys + [colon],lsp1,lvalu);
-                    if string(lsp1) then
+                    if strng(lsp1) then
                       begin error(148); lsp1 := nil end;
                     with lsp^ do
                       begin rangetype:=lsp1; min:=lvalu; size:=intsize end;
@@ -1178,9 +1178,9 @@ var
                       begin align(lsp1,displ);
                         lcp^.fldaddr := displ;
                         displ := displ+lsp1^.size;
-                        if (lsp1^.form <= subrange) or string(lsp1) then
+                        if (lsp1^.form <= subrange) or strng(lsp1) then
                           begin if comptypes(realptr,lsp1) then error(109)
-                            else if string(lsp1) then error(399);
+                            else if strng(lsp1) then error(399);
                             lcp^.idtype := lsp1; lsp^.tagfieldp := lcp;
                           end
                         else error(110);
@@ -2011,7 +2011,7 @@ var
           if typtr <> nil then
             begin
               case kind of
-                cst:   if string(typtr) then
+                cst:   if strng(typtr) then
                          if cstptrix >= cstoccmax then error(254)
                          else
                            begin cstptrix := cstptrix + 1;
@@ -2371,7 +2371,7 @@ var
                         begin
                           if lsp^.form = scalar then error(399)
                           else
-                            if string(lsp) then
+                            if strng(lsp) then
                               begin len := lsp^.size div charmax;
                                 if default then
                                       gen2(51(*ldc*),1,len);
@@ -2476,7 +2476,7 @@ var
                   if lsp^.form <> tagfld then error(162)
                   else
                     if lsp^.tagfieldp <> nil then
-                      if string(lsp1) or (lsp1 = realptr) then error(159)
+                      if strng(lsp1) or (lsp1 = realptr) then error(159)
                       else
                         if comptypes(lsp^.tagfieldp^.idtype,lsp1) then
                           begin
@@ -2737,13 +2737,13 @@ var
         end (*call*) ;
 
         procedure expression;
-          var lattr: attr; lop: operator; typind: char; lsize: addrrange;
+          var lattr: attr; lop: operatr; typind: char; lsize: addrrange;
 
           procedure simpleexpression(fsys: setofsys);
-            var lattr: attr; lop: operator; signed: boolean;
+            var lattr: attr; lop: operatr; signed: boolean;
 
             procedure term(fsys: setofsys);
-              var lattr: attr; lop: operator;
+              var lattr: attr; lop: operatr;
 
               procedure factor(fsys: setofsys);
                 var lcp: ctp; lvp: csp; varpart: boolean;
@@ -3074,7 +3074,7 @@ var
                             end;
                           arrays:
                             begin
-                              if not string(lattr.typtr)
+                              if not strng(lattr.typtr)
                                 then error(134);
                               typind := 'm'
                             end;

commit f076116b3bd6c1b486526bcfdf7ee7925edec76d
Author: Christophe Staïesse <chastai@skynet.be>
Date:   Sat Jul 13 11:46:55 2013 +0200

    Remove the only dependence to file buffer variable
    
    File buffer variable access through the caret syntax (input^) is not
    supported in FPC and Delphi.
    
    This is used in one place: when recognizing a number and encountering a
    point, it tests if the point is followed by another point (i.e. if it's
    a decimal point or the '..' operator).
    
    In fact, the code from the print version of the book doesn't depend on
    buffer accesses, so I reverted back this part to the original code (the
    differences between the printed and online version are available at
    http://homepages.cwi.nl/~steven/pascal/).
    
    But now, we have a goto which point inside an else clause but FPC and
    Delphi support that.

diff --git a/pcom.pas b/pcom.pas
index 660458b..e9e0025 100644
--- a/pcom.pas
+++ b/pcom.pas
@@ -426,12 +426,12 @@ var
         begin op := noop; i := 0;
           repeat i := i+1; if i<= digmax then digit[i] := ch; nextch
           until chartp[ch] <> number;
-          if ((ch = '.') and (input^ <> '.')) or (ch = 'e') then
+          if (ch = '.') or (ch = 'e') then
             begin
                   k := i;
                   if ch = '.' then
                     begin k := k+1; if k <= digmax then digit[k] := ch;
-                      nextch; (*if ch = '.' then begin ch := ':'; goto 3 end;*)
+                      nextch; if ch = '.' then begin ch := ':'; goto 3 end;
                       if chartp[ch] <> number then error(201)
                       else
                         repeat k := k + 1;

commit c00b96ac6b293add4aa629fa6ead041f6094231a
Author: Christophe Staïesse <chastai@skynet.be>
Date:   Sat Jul 13 18:26:36 2013 +0200

    Show tag field parameters of new to PP only
    
    as this is not supported by FPC nor Delphi.
    We keep them for PP as this will reduce the memory usage when pint will
    interpret pcom.

diff --git a/pcom.pas b/pcom.pas
index e9e0025..e84bfcc 100644
--- a/pcom.pas
+++ b/pcom.pas
@@ -451,7 +451,7 @@ var
                           if k <= digmax then digit[k] := ch; nextch
                         until chartp[ch] <> number
                      end;
-                   new(lvp,reel); sy:= realconst; lvp^.cclass := reel;
+                   new(lvp (*$IFDEF PP*),reel(*$ENDIF*)); sy:= realconst; lvp^.cclass := reel;
                    with lvp^ do
                      begin for i := 1 to strglgth do rval[i] := ' ';
                        if k <= digmax then
@@ -490,7 +490,7 @@ var
           if lgth = 0 then error(205) else
           if lgth = 1 then val.ival := ord(strng[1])
           else
-            begin new(lvp,strg); lvp^.cclass:=strg;
+            begin new(lvp (*$IFDEF PP*),strg(*$ENDIF*)); lvp^.cclass:=strg;
               if lgth > strglgth then
                 begin error(399); lgth := strglgth end;
               with lvp^ do
@@ -874,7 +874,7 @@ var
               if lgth = 1 then lsp := charptr
               else
                 begin
-                  new(lsp,arrays);
+                  new(lsp (*$IFDEF PP*),arrays(*$ENDIF*));
                   with lsp^ do
                     begin aeltype := charptr; inxtype := nil;
                        size := lgth*charsize; form := arrays
@@ -900,7 +900,7 @@ var
                       if lsp = realptr then
                         begin
                           if sign = neg then
-                            begin new(lvp,reel);
+                            begin new(lvp (*$IFDEF PP*),reel(*$ENDIF*));
                               if fvalu.valp^.rval[1] = '-' then
                                 lvp^.rval[1] := '+'
                               else lvp^.rval[1] := '-';
@@ -1037,7 +1037,7 @@ var
             if sy = lparent then
               begin ttop := top;   (*decl. consts local to innermost block*)
                 while display[top].occur <> blck do top := top - 1;
-                new(lsp,scalar,declared);
+                new(lsp (*$IFDEF PP*),scalar,declared(*$ENDIF*));
                 with lsp^ do
                   begin size := intsize; form := scalar;
                     scalkind := declared
@@ -1045,7 +1045,7 @@ var
                 lcp1 := nil; lcnt := 0;
                 repeat insymbol;
                   if sy = ident then
-                    begin new(lcp,konst);
+                    begin new(lcp (*$IFDEF PP*),konst(*$ENDIF*));
                       with lcp^ do
                         begin name := id; idtype := lsp; next := lcp1;
                           values.ival := lcnt; klass := konst
@@ -1067,7 +1067,7 @@ var
                   begin searchid([types,konst],lcp);
                     insymbol;
                     if lcp^.klass = konst then
-                      begin new(lsp,subrange);
+                      begin new(lsp (*$IFDEF PP*),subrange(*$ENDIF*));
                         with lsp^, lcp^ do
                           begin rangetype := idtype; form := subrange;
                             if strng(rangetype) then
@@ -1085,7 +1085,7 @@ var
                       end
                   end (*sy = ident*)
                 else
-                  begin new(lsp,subrange); lsp^.form := subrange;
+                  begin new(lsp (*$IFDEF PP*),subrange(*$ENDIF*)); lsp^.form := subrange;
                     constant(fsys + [colon],lsp1,lvalu);
                     if strng(lsp1) then
                       begin error(148); lsp1 := nil end;
@@ -1121,7 +1121,7 @@ var
           begin nxt := nxt1;
             repeat
               if sy = ident then
-                begin new(lcp,field);
+                begin new(lcp (*$IFDEF PP*),field(*$ENDIF*));
                   with lcp^ do
                     begin name := id; idtype := nil; next := nxt;
                       klass := field
@@ -1157,13 +1157,13 @@ var
           with nxt1^ do
             begin lcp := next; next := nxt; nxt := nxt1; nxt1 := lcp end;
         if sy = casesy then
-          begin new(lsp,tagfld);
+          begin new(lsp (*$IFDEF PP*),tagfld(*$ENDIF*));
             with lsp^ do
               begin tagfieldp := nil; fstvar := nil; form:=tagfld end;
             frecvar := lsp;
             insymbol;
             if sy = ident then
-              begin new(lcp,field);
+              begin new(lcp (*$IFDEF PP*),field(*$ENDIF*));
                 with lcp^ do
                   begin name := id; idtype := nil; klass:=field;
                     next := nil; fldaddr := displ
@@ -1199,7 +1199,7 @@ var
                 repeat constant(fsys + [comma,colon,lparent],lsp3,lvalu);
                   if lsp^.tagfieldp <> nil then
                    if not comptypes(lsp^.tagfieldp^.idtype,lsp3)then error(111);
-                  new(lsp3,variant);
+                  new(lsp3 (*$IFDEF PP*),variant(*$ENDIF*));
                   with lsp3^ do
                     begin nxtvar := lsp1; subvar := lsp2; varval := lvalu;
                       form := variant
@@ -1251,7 +1251,7 @@ var
           if sy in simptypebegsys then simpletype(fsys,fsp,fsize)
           else
     (*^*)     if sy = arrow then
-              begin new(lsp,pointer); fsp := lsp;
+              begin new(lsp (*$IFDEF PP*),pointer(*$ENDIF*)); fsp := lsp;
                 with lsp^ do
                   begin eltype := nil; size := ptrsize; form:=pointer end;
                 insymbol;
@@ -1259,7 +1259,7 @@ var
                   begin prterr := false; (*no error if search not successful*)
                     searchid([types],lcp); prterr := true;
                     if lcp = nil then   (*forward referenced type id*)
-                      begin new(lcp,types);
+                      begin new(lcp (*$IFDEF PP*),types(*$ENDIF*));
                         with lcp^ do
                           begin name := id; idtype := lsp;
                             next := fwptr; klass := types
@@ -1289,7 +1289,7 @@ var
                   begin insymbol;
                     if sy = lbrack then insymbol else error(11);
                     lsp1 := nil;
-                    repeat new(lsp,arrays);
+                    repeat new(lsp (*$IFDEF PP*),arrays(*$ENDIF*));
                       with lsp^ do
                         begin aeltype := lsp1; inxtype := nil; form:=arrays end;
                       lsp1 := lsp;
@@ -1340,7 +1340,7 @@ var
                       else error(250);
                       displ := 0;
                       fieldlist(fsys-[semicolon]+[endsy],lsp1);
-                      new(lsp,records);
+                      new(lsp (*$IFDEF PP*),records(*$ENDIF*));
                       with lsp^ do
                         begin fstfld := display[top].fname;
                           recvar := lsp1; size := displ; form := records
@@ -1366,7 +1366,7 @@ var
                                 if (lmin < setlow) or (lmax > sethigh)
                                   then error(169);
                               end;
-                        new(lsp,power);
+                        new(lsp (*$IFDEF PP*),power(*$ENDIF*));
                         with lsp^ do
                           begin elset:=lsp1; size:=setsize; form:=power end;
                       end
@@ -1420,7 +1420,7 @@ var
       if sy <> ident then
         begin error(2); skip(fsys + [ident]) end;
       while sy = ident do
-        begin new(lcp,konst);
+        begin new(lcp (*$IFDEF PP*),konst(*$ENDIF*));
           with lcp^ do
             begin name := id; idtype := nil; next := nil; klass:=konst end;
           insymbol;
@@ -1443,7 +1443,7 @@ var
       if sy <> ident then
         begin error(2); skip(fsys + [ident]) end;
       while sy = ident do
-        begin new(lcp,types);
+        begin new(lcp (*$IFDEF PP*),types(*$ENDIF*));
           with lcp^ do
             begin name := id; idtype := nil; klass := types end;
           insymbol;
@@ -1486,7 +1486,7 @@ var
       repeat
         repeat
           if sy = ident then
-            begin new(lcp,vars);
+            begin new(lcp (*$IFDEF PP*),vars(*$ENDIF*));
               with lcp^ do
                begin name := id; next := nxt; klass := vars;
                   idtype := nil; vkind := actual; vlev := level
@@ -1547,7 +1547,7 @@ var
                   begin error(399);
                     repeat insymbol;
                       if sy = ident then
-                        begin new(lcp,proc,declared,formal);
+                        begin new(lcp (*$IFDEF PP*),proc,declared,formal(*$ENDIF*));
                           with lcp^ do
                             begin name := id; idtype := nil; next := lcp1;
                               pflev := level (*beware of parameter procedures*);
@@ -1570,7 +1570,7 @@ var
                       begin error(399); lcp2 := nil;
                         repeat insymbol;
                           if sy = ident then
-                            begin new(lcp,func,declared,formal);
+                            begin new(lcp (*$IFDEF PP*),func,declared,formal(*$ENDIF*));
                               with lcp^ do
                                 begin name := id; idtype := nil; next := lcp2;
                                   pflev := level (*beware param funcs*);
@@ -1618,7 +1618,7 @@ var
                         count := 0;
                         repeat
                           if sy = ident then
-                            begin new(lcp,vars);
+                            begin new(lcp (*$IFDEF PP*),vars(*$ENDIF*));
                               with lcp^ do
                                 begin name:=id; idtype:=nil; klass:=vars;
                                   vkind := lkind; next := lcp2; vlev := level;
@@ -1715,8 +1715,8 @@ var
             end;
           if not forw then
             begin
-              if fsy = procsy then new(lcp,proc,declared,actual)
-              else new(lcp,func,declared,actual);
+              if fsy = procsy then new(lcp (*$IFDEF PP*),proc,declared,actual(*$ENDIF*))
+              else new(lcp (*$IFDEF PP*),func,declared,actual(*$ENDIF*));
               with lcp^ do
                 begin name := id; idtype := nil;
                   externl := false; pflev := level; genlabel(lbname);
@@ -2804,7 +2804,7 @@ var
                             begin
                               if lgth = 1 then typtr := charptr
                               else
-                                begin new(lsp,arrays);
+                                begin new(lsp (*$IFDEF PP*),arrays(*$ENDIF*));
                                   with lsp^ do
                                     begin aeltype := charptr; form:=arrays;
                                       inxtype := nil; size := lgth*charsize
@@ -2828,7 +2828,7 @@ var
                         end;
               (*[*)     lbrack:
                         begin insymbol; cstpart := [ ]; varpart := false;
-                          new(lsp,power);
+                          new(lsp (*$IFDEF PP*),power(*$ENDIF*));
                           with lsp^ do
                             begin elset:=nil;size:=setsize;form:=power end;
                           if sy = rbrack then
@@ -2872,7 +2872,7 @@ var
                           if varpart then
                             begin
                               if cstpart <> [ ] then
-                                begin new(lvp,pset); lvp^.pval := cstpart;
+                                begin new(lvp (*$IFDEF PP*),pset(*$ENDIF*)); lvp^.pval := cstpart;
                                   lvp^.cclass := pset;
                                   if cstptrix = cstoccmax then error(254)
                                   else
@@ -2884,7 +2884,7 @@ var
                                 end
                             end
                           else
-                            begin new(lvp,pset); lvp^.pval := cstpart;
+                            begin new(lvp (*$IFDEF PP*),pset(*$ENDIF*)); lvp^.pval := cstpart;
                               lvp^.cclass := pset;
                               gattr.cval.valp := lvp
                             end
@@ -3643,25 +3643,25 @@ var
   begin                                                 (*type underlying:*)
                                                         (******************)
 
-    new(intptr,scalar,standard);                             (*integer*)
+    new(intptr (*$IFDEF PP*),scalar,standard(*$ENDIF*));                             (*integer*)
     with intptr^ do
       begin size := intsize; form := scalar; scalkind := standard end;
-    new(realptr,scalar,standard);                            (*real*)
+    new(realptr (*$IFDEF PP*),scalar,standard(*$ENDIF*));                            (*real*)
     with realptr^ do
       begin size := realsize; form := scalar; scalkind := standard end;
-    new(charptr,scalar,standard);                            (*char*)
+    new(charptr (*$IFDEF PP*),scalar,standard(*$ENDIF*));                            (*char*)
     with charptr^ do
       begin size := charsize; form := scalar; scalkind := standard end;
-    new(boolptr,scalar,declared);                            (*boolean*)
+    new(boolptr (*$IFDEF PP*),scalar,declared(*$ENDIF*));                            (*boolean*)
     with boolptr^ do
       begin size := boolsize; form := scalar; scalkind := declared end;
-    new(nilptr,pointer);                                     (*nil*)
+    new(nilptr (*$IFDEF PP*),pointer(*$ENDIF*));                                     (*nil*)
     with nilptr^ do
       begin eltype := nil; size := ptrsize; form := pointer end;
-    new(parmptr,scalar,standard); (*for alignment of parameters*)
+    new(parmptr (*$IFDEF PP*),scalar,standard(*$ENDIF*)); (*for alignment of parameters*)
     with parmptr^ do
       begin size := parmsize; form := scalar; scalkind := standard end ;
-    new(textptr,files);                                      (*text*)
+    new(textptr (*$IFDEF PP*),files(*$ENDIF*));                                      (*text*)
     with textptr^ do
       begin filtype := charptr; size := charsize; form := files end
   end (*enterstdtypes*) ;
@@ -3671,25 +3671,25 @@ var
   begin                                                      (*name:*)
                                                              (*******)
 
-    new(cp,types);                                          (*integer*)
+    new(cp (*$IFDEF PP*),types(*$ENDIF*));                                          (*integer*)
     with cp^ do
       begin name := 'integer '; idtype := intptr; klass := types end;
     enterid(cp);
-    new(cp,types);                                          (*real*)
+    new(cp (*$IFDEF PP*),types(*$ENDIF*));                                          (*real*)
     with cp^ do
       begin name := 'real    '; idtype := realptr; klass := types end;
     enterid(cp);
-    new(cp,types);                                          (*char*)
+    new(cp (*$IFDEF PP*),types(*$ENDIF*));                                          (*char*)
     with cp^ do
       begin name := 'char    '; idtype := charptr; klass := types end;
     enterid(cp);
-    new(cp,types);                                          (*boolean*)
+    new(cp (*$IFDEF PP*),types(*$ENDIF*));                                          (*boolean*)
     with cp^ do
       begin name := 'boolean '; idtype := boolptr; klass := types end;
     enterid(cp);
     cp1 := nil;
     for i := 1 to 2 do
-      begin new(cp,konst);                                  (*false,true*)
+      begin new(cp (*$IFDEF PP*),konst(*$ENDIF*));                                  (*false,true*)
         with cp^ do
           begin name := na[i]; idtype := boolptr;
             next := cp1; values.ival := i - 1; klass := konst
@@ -3697,14 +3697,14 @@ var
         enterid(cp); cp1 := cp
       end;
     boolptr^.fconst := cp;
-    new(cp,konst);                                          (*nil*)
+    new(cp (*$IFDEF PP*),konst(*$ENDIF*));                                          (*nil*)
     with cp^ do
       begin name := 'nil     '; idtype := nilptr;
         next := nil; values.ival := 0; klass := konst
       end;
     enterid(cp);
     for i := 3 to 4 do
-      begin new(cp,vars);                                    (*input,output*)
+      begin new(cp (*$IFDEF PP*),vars(*$ENDIF*));                                    (*input,output*)
         with cp^ do
           begin name := na[i]; idtype := textptr; klass := vars;
             vkind := actual; next := nil; vlev := 1;
@@ -3713,7 +3713,7 @@ var
         enterid(cp)
       end;
     for i:=33 to 34 do
-      begin new(cp,vars);                                    (*prd,prr files*)
+      begin new(cp (*$IFDEF PP*),vars(*$ENDIF*));                                    (*prd,prr files*)
          with cp^ do
            begin name := na[i]; idtype := textptr; klass := vars;
               vkind := actual; next := nil; vlev := 1;
@@ -3722,7 +3722,7 @@ var
          enterid(cp)
       end;
     for i := 5 to 16 do
-      begin new(cp,proc,standard);                      (*get,put,reset*)
+      begin new(cp (*$IFDEF PP*),proc,standard(*$ENDIF*));                      (*get,put,reset*)
         with cp^ do                                     (*rewrite,read*)
           begin name := na[i]; idtype := nil;           (*write,pack*)
             next := nil; key := i - 4;                  (*unpack,pack*)
@@ -3730,14 +3730,14 @@ var
           end;
         enterid(cp)
       end;
-    new(cp,proc,standard);
+    new(cp (*$IFDEF PP*),proc,standard(*$ENDIF*));
     with cp^ do
       begin name:=na[35]; idtype:=nil;
             next:= nil; key:=13;
             klass:=proc; pfdeckind:= standard
       end; enterid(cp);
     for i := 17 to 26 do
-      begin new(cp,func,standard);                          (*abs,sqr,trunc*)
+      begin new(cp (*$IFDEF PP*),func,standard(*$ENDIF*));                          (*abs,sqr,trunc*)
         with cp^ do                                        (*odd,ord,chr*)
           begin name := na[i]; idtype := nil;            (*pred,succ,eof*)
             next := nil; key := i - 16;
@@ -3745,13 +3745,13 @@ var
           end;
         enterid(cp)
       end;
-    new(cp,vars);                     (*parameter of predeclared functions*)
+    new(cp (*$IFDEF PP*),vars(*$ENDIF*));                     (*parameter of predeclared functions*)
     with cp^ do
       begin name := '        '; idtype := realptr; klass := vars;
         vkind := actual; next := nil; vlev := 1; vaddr := 0
       end;
     for i := 27 to 32 do
-      begin new(cp1,func,declared,actual);                (*sin,cos,exp*)
+      begin new(cp1 (*$IFDEF PP*),func,declared,actual(*$ENDIF*));                (*sin,cos,exp*)
         with cp1^ do                                      (*sqrt,ln,arctan*)
           begin name := na[i]; idtype := realptr; next := cp;
             forwdecl := false; externl := true; pflev := 0; pfname := i - 12;
@@ -3763,31 +3763,31 @@ var
 
   procedure enterundecl;
   begin
-    new(utypptr,types);
+    new(utypptr (*$IFDEF PP*),types(*$ENDIF*));
     with utypptr^ do
       begin name := '        '; idtype := nil; klass := types end;
-    new(ucstptr,konst);
+    new(ucstptr (*$IFDEF PP*),konst(*$ENDIF*));
     with ucstptr^ do
       begin name := '        '; idtype := nil; next := nil;
         values.ival := 0; klass := konst
       end;
-    new(uvarptr,vars);
+    new(uvarptr (*$IFDEF PP*),vars(*$ENDIF*));
     with uvarptr^ do
       begin name := '        '; idtype := nil; vkind := actual;
         next := nil; vlev := 0; vaddr := 0; klass := vars
       end;
-    new(ufldptr,field);
+    new(ufldptr (*$IFDEF PP*),field(*$ENDIF*));
     with ufldptr^ do
       begin name := '        '; idtype := nil; next := nil; fldaddr := 0;
         klass := field
       end;
-    new(uprcptr,proc,declared,actual);
+    new(uprcptr (*$IFDEF PP*),proc,declared,actual(*$ENDIF*));
     with uprcptr^ do
       begin name := '        '; idtype := nil; forwdecl := false;
         next := nil; externl := false; pflev := 0; genlabel(pfname);
         klass := proc; pfdeckind := declared; pfkind := actual
       end;
-    new(ufctptr,func,declared,actual);
+    new(ufctptr (*$IFDEF PP*),func,declared,actual(*$ENDIF*));
     with ufctptr^ do
       begin name := '        '; idtype := nil; next := nil;
         forwdecl := false; externl := false; pflev := 0; genlabel(pfname);

commit 35de1973cdeb5eadb4a6651c1ad889d9a878f9bd
Author: Christophe Staïesse <chastai@skynet.be>
Date:   Sat Jul 13 18:33:02 2013 +0200

    Comment out procedure printtable
    
    This procedure is called with $t+ option. It dumps the symbol table.
    This procedure print addresses by applying Ord() on pointer variables.
    This is not supported by FPC nor by Delphi.
    
    So, the tables dump option do nothing for now when pcom is compiled by
    another compiler.

diff --git a/pcom.pas b/pcom.pas
index e84bfcc..8ec2064 100644
--- a/pcom.pas
+++ b/pcom.pas
@@ -672,7 +672,7 @@ var
     l := flc-1;
     flc := l + k  -  (k+l) mod k
   end (*align*);
-
+(*$IFDEF PP*)
   procedure printtables(fb: boolean);
     (*print data structure and name table*)
     var i, lim: disprange;
@@ -843,7 +843,7 @@ var
     writeln(output);
     if not eol then write(output,' ':chcnt+16)
   end (*printtables*);
-
+(*$ENDIF*)
   procedure genlabel(var nxtlab: integer);
   begin intlabel := intlabel + 1;
     nxtlab := intlabel
@@ -1794,7 +1794,7 @@ var
         begin lcp^.forwdecl := false; mark(markp);
           repeat block(fsys,semicolon,lcp);
             if sy = semicolon then
-              begin if prtables then printtables(false); insymbol;
+              begin (*$IFDEF PP*)if prtables then printtables(false);(*$ENDIF*) insymbol;
                 if not (sy in [beginsy,procsy,funcsy]) then
                   begin error(6); skip(fsys) end
               end
@@ -3557,9 +3557,9 @@ var
                 fextfilep := fextfilep^.nextfile
             end;
           id := saveid;
-          if prtables then
+          (*$IFDEF PP*)if prtables then
             begin writeln(output); printtables(true)
-            end
+            end(*$ENDIF*)
         end;
     end (*body*) ;
 

commit 962943cc67a2455e853dc6f99ea6077745544e95
Author: Christophe Staïesse <chastai@skynet.be>
Date:   Sat Jul 13 18:50:25 2013 +0200

    Solve problem with proc expression forward decl
    
    With Free Pascal, parameters also need to be declared in a procedure
    definition even if the procedure has been forward declared.
    
    With Pascal-P, we can't redeclare the parameters in the definition,
    so we will use a conditional directive and a preprocessor wil be needed
    to compile pcom with itself.

diff --git a/pcom.pas b/pcom.pas
index 8ec2064..1718423 100644
--- a/pcom.pas
+++ b/pcom.pas
@@ -2736,7 +2736,7 @@ var
           else callnonstandard
         end (*call*) ;
 
-        procedure expression;
+        procedure expression(*$IFNDEF PP*)(fsys: setofsys)(*$ENDIF*);
           var lattr: attr; lop: operatr; typind: char; lsize: addrrange;
 
           procedure simpleexpression(fsys: setofsys);

commit a71b6e0d4dfbb25cb6df5f0bd5b3f1d4e581289c
Author: Christophe Staïesse <chastai@skynet.be>
Date:   Sat Jul 13 19:03:16 2013 +0200

    Set ordmaxchar to 255
    
    ordmaxchar defines the max value of a char.

diff --git a/pcom.pas b/pcom.pas
index 1718423..6553849 100644
--- a/pcom.pas
+++ b/pcom.pas
@@ -49,7 +49,7 @@ const displimit = 20; maxlevel = 10;
    strglgth    =     16;
    sethigh     =     47;
    setlow      =      0;
-   ordmaxchar  =     63;
+   ordmaxchar  =    255;
    ordminchar  =      0;
    maxint      =  32767;
    lcaftermarkstack = 5;

commit c345ec56025880eb777d45d2d0a0444d1e8653cd
Author: Christophe Staïesse <chastai@skynet.be>
Date:   Sat Jul 13 19:12:21 2013 +0200

    Assign a filename to prr

diff --git a/pcom.pas b/pcom.pas
index 6553849..48d6f26 100644
--- a/pcom.pas
+++ b/pcom.pas
@@ -3992,7 +3992,7 @@ begin
     begin fname := nil; flabel := nil; occur := blck end;
 
 
-  (*compile:*) rewrite(prr); (*comment this out when compiling with pcom *)
+  (*compile:*) assign(prr,'prr'); rewrite(prr); (*comment this out when compiling with pcom *)
   (**********)
   insymbol;
   programme(blockbegsys+statbegsys-[casesy]);

commit f7db76f3388204b8ed3db59b70333bbe6ac0d2a1
Author: Christophe Staïesse <chastai@skynet.be>
Date:   Sat Jul 13 20:39:14 2013 +0200

    Hide prr declaration and file opening from pcom

diff --git a/pcom.pas b/pcom.pas
index 48d6f26..49761e1 100644
--- a/pcom.pas
+++ b/pcom.pas
@@ -191,7 +191,7 @@ type                                                    (*describing:*)
 (*-------------------------------------------------------------------------*)
 
 var
-    prr: text; (* comment this out when compiling with pcom *)
+    (*$IFNDEF PP*)prr: text;(*$ENDIF*)
                                     (*returned by source program scanner
                                      insymbol:
                                      **********)
@@ -3992,7 +3992,7 @@ begin
     begin fname := nil; flabel := nil; occur := blck end;
 
 
-  (*compile:*) assign(prr,'prr'); rewrite(prr); (*comment this out when compiling with pcom *)
+  (*compile:*) (*$IFNDEF PP*)assign(prr,'prr'); rewrite(prr);(*$ENDIF*)
   (**********)
   insymbol;
   programme(blockbegsys+statbegsys-[casesy]);

commit e475c03e0f264161ad7ec869dd54c482dc5bc9eb
Author: Christophe Staïesse <chastai@skynet.be>
Date:   Sat Jul 13 20:51:46 2013 +0200

    Close prr after compilation
    
    This was causing lost of data with FPC.

diff --git a/pcom.pas b/pcom.pas
index 49761e1..33494e0 100644
--- a/pcom.pas
+++ b/pcom.pas
@@ -3996,5 +3996,5 @@ begin
   (**********)
   insymbol;
   programme(blockbegsys+statbegsys-[casesy]);
-
+  (*$IFNDEF PP*)close(prr);(*$ENDIF*)
 end.

commit 318dd798ed5fd836d5202826360e203cc149db00
Author: Christophe Staïesse <chastai@skynet.be>
Date:   Sat Jul 13 21:03:34 2013 +0200

    Hide PP compilation directives to other compilers

diff --git a/pcom.pas b/pcom.pas
index 33494e0..5438858 100644
--- a/pcom.pas
+++ b/pcom.pas
@@ -1,4 +1,4 @@
-(*$c+,t-,d-,l-*)
+(*$IFDEF PP*)(*$c+,t-,d-,l-*)(*$ENDIF*)
  (***********************************************
   *                                             *
   *      Portable Pascal compiler               *

commit f253cc0f094b0b0d5f6455637d4126b92de99279
Author: Christophe Staïesse <chastai@skynet.be>
Date:   Sat Jul 13 21:24:37 2013 +0200

    Solve an EOLN problem in Delphi
    
    In proc nextch, it was assumed that EOLN took no more than one char.

diff --git a/pcom.pas b/pcom.pas
index 5438858..4cf9f1f 100644
--- a/pcom.pas
+++ b/pcom.pas
@@ -360,7 +360,7 @@ var
       begin if list then writeln(output); endofline
       end;
       if not eof(input) then
-       begin eol := eoln(input); read(input,ch);
+       begin eol := eoln; if eol then begin ch := ' '; readln end else read(ch);
         if list then write(output,ch);
         chcnt := chcnt + 1
        end

commit f8324894666f48463771d5cb183bebd79c46d77f
Author: Christophe Staïesse <chastai@skynet.be>
Date:   Sun Jul 14 09:15:08 2013 +0200

    Set the debug flag to on in pcom
    
    To force bound checking.

diff --git a/pcom.pas b/pcom.pas
index 4cf9f1f..2bc8d66 100644
--- a/pcom.pas
+++ b/pcom.pas
@@ -1,4 +1,4 @@
-(*$IFDEF PP*)(*$c+,t-,d-,l-*)(*$ENDIF*)
+(*$IFDEF PP*)(*$c+,t-,d+,l-*)(*$ENDIF*)
  (***********************************************
   *                                             *
   *      Portable Pascal compiler               *

commit 8bd2e84ddc44c6e06c73ceb70ef8915637adf28c
Author: Christophe Staïesse <chastai@skynet.be>
Date:   Sun Jul 14 12:02:57 2013 +0200

    Hide the dummy Mark and Release procs to PP
    
    As Mark and Release are implemented and used by pcom, that will
    preserve memory and pint will be able to execute pcom without
    increasing the data store.

diff --git a/pcom.pas b/pcom.pas
index 2bc8d66..8821a78 100644
--- a/pcom.pas
+++ b/pcom.pas
@@ -297,8 +297,8 @@ var
 
     intlabel,mxint10,digmax: integer;
 (*-------------------------------------------------------------------------*)
-  procedure mark(var p: marktype); begin end;
-  procedure release(p: marktype); begin end;
+  (*$IFNDEF PP*)procedure mark(var p: marktype); begin end;(*$ENDIF*)
+  (*$IFNDEF PP*)procedure release(p: marktype); begin end;(*$ENDIF*)
 
   procedure endofline;
     var lastpos,freepos,currpos,currnmr,f,k: integer;

commit 2cad116d3f4e97426e9a8228a093cfd71d34db64
Author: Christophe Staïesse <chastai@skynet.be>
Date:   Fri Aug 2 10:32:56 2013 +0200

    Fix number alignment problems in code generator
    
    When generating LDC(, numbers are aligned on 3 chars. A set member >99
    would not be padded with spaces and so would extend the previous number.
    
    Simarly in gen2t which is notably used by CHKA and CHKI the numbers are
    aligned on 8 chars. This is not enough if maxint > 99 999 999.
    
    By example:
     ldc( 100101)
     chka 12147483647

diff --git a/pcom.pas b/pcom.pas
index 8821a78..679d590 100644
--- a/pcom.pas
+++ b/pcom.pas
@@ -1892,7 +1892,7 @@ var
                   5: begin write(prr,'(');
                        with cstptr[fp2]^ do
                          for k := setlow to sethigh do
-                           if k in pval then write(prr,k:3);
+                           if k in pval then write(prr,' ',k);
                        writeln(prr,')')
                      end
                 end
@@ -1950,7 +1950,7 @@ var
           begin putic;
             write(prr,mn[fop]: 4);
             gentypindicator(fsp);
-            writeln(prr,fp1:3+5*ord(abs(fp1)>99),fp2:8);
+            writeln(prr,' ',fp1,' ',fp2);
           end;
         ic := ic + 1; mes(fop)
       end (*gen2t*);

commit bbc6067fd37c14a90877990dfc6fa34848c7316c
Author: Christophe Staïesse <chastai@skynet.be>
Date:   Wed Aug 7 10:50:25 2013 +0200

    Add modification notices to pint.pas and pcom.pas

diff --git a/pcom.pas b/pcom.pas
index 679d590..e058cc8 100644
--- a/pcom.pas
+++ b/pcom.pas
@@ -27,7 +27,7 @@
   * Steven.Pemberton@cwi.nl                     *
   *                                             *
   ***********************************************)
-
+(* Ported to Free Pascal and Delphi by Christope Staiesse, 08/2013 *)
 program pascalcompiler(input,output,prr);
 
 const displimit = 20; maxlevel = 10;
